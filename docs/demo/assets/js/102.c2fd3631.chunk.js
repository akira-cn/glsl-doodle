(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{554:function(n,e,o){"use strict";o.r(e),e.default="// https://www.shadertoy.com/view/MdX3zr\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#pragma include <stdlib>\n\nuniform vec2 dd_resolution;\nuniform float dd_time;\n\nfloat sphere(vec3 p, vec4 spr)\n{\n  return length(spr.xyz-p) - spr.w;\n}\n\nfloat flame(vec3 p)\n{\n  float d = sphere(p*vec3(1.,.5,1.), vec4(.0,-1.,.0,1.));\n  return d + (noise(p+vec3(.0,dd_time*2.,0.)) + noise(p*3.)*.5)*.25*(p.y) ;\n}\n\nfloat scene(vec3 p)\n{\n  return min(100.-length(p) , abs(flame(p)) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n  float d = 0.0, glow = 0.0, eps = 0.02;\n  vec3  p = org;\n  bool glowed = false;\n  \n  for(int i=0; i<64; i++)\n  {\n  \td = scene(p) + eps;\n  \tp += d * dir;\n  \tif( d>eps )\n  \t{\n  \t\tif(flame(p) < .0)\n  \t\t\tglowed=true;\n  \t\tif(glowed)\n       \t\t\tglow = float(i)/64.;\n  \t}\n  }\n  return vec4(p,glow);\n}\n\nvoid main()\n{\n  vec2 v = -1.0 + 2.0 * gl_FragCoord.xy / dd_resolution.xy;\n  v.x *= dd_resolution.x/dd_resolution.y;\n\n  vec3 org = vec3(0., -2., 4.);\n  vec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\n\n  vec4 p = raymarch(org, dir);\n  float glow = p.w;\n\n  vec3 col = mix(vec3(1.,.5,.1), vec3(0.1,.5,1.), p.y*.02+.4);\n  \n  gl_FragColor.rgb = mix(vec3(0.), col, pow(glow*2.,4.));\n  gl_FragColor.a = 1.0;\n  //fragColor = mix(vec4(1.), mix(vec4(1.,.5,.1,1.),vec4(0.1,.5,1.,1.),p.y*.02+.4), pow(glow*2.,4.));\n}\n"}}]);